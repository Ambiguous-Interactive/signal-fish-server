# Release Workflow - Publish Crate and Create GitHub Release
#
# Publishes the crate to crates.io and creates a GitHub Release with changelog.
#
# Runs on:
#   - Manual workflow dispatch (with version input)
#   - Tag pushes matching v* pattern
#
# Release gating:
#   A `preflight` job verifies that required CI workflows ("CI" and
#   "Documentation Validation") have passed on the commit being released
#   before the `publish` job runs. This prevents publishing a broken crate.
#
# Concurrency:
#   cancel-in-progress is set to false because aborting a half-finished
#   publish could leave crates.io in an inconsistent state.
#
# Pinning philosophy:
#   All third-party GitHub Actions are SHA-pinned with version comments.
#   Explicit tool version pins are intentionally omitted where the
#   SHA-pinned action handles versioning, reducing maintenance burden.
#
# Steps:
#   1. Preflight: verify CI and doc-validation passed on this commit
#   2. Verify version consistency (tag vs Cargo.toml)
#   3. Dry-run publish to validate packaging
#   4. Publish to crates.io
#   5. Create git tag (for workflow_dispatch)
#   6. Generate SBOM (CycloneDX JSON) for supply-chain provenance
#   7. Extract changelog section and create GitHub Release (with SBOM attached)

name: Release - Publish Crate

on:
  workflow_dispatch:
    inputs:
      release_version:
        description: "Version to publish, e.g. 0.1.0 (must match Cargo.toml, no 'v' prefix)"
        required: true
  push:
    tags:
      - "v*"

permissions:
  contents: write
  actions: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  CARGO_TERM_COLOR: always

jobs:
  preflight:
    name: Preflight
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Verify required CI checks passed
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          # github.sha resolves to the underlying commit for both tag pushes
          # and workflow_dispatch events
          COMMIT_SHA="${{ github.sha }}"
          echo "Verifying CI status for commit: $COMMIT_SHA"

          # Required workflow runs that must have completed successfully.
          # These correspond to the REQUIRED_WORKFLOW_NAMES in tests/ci_config_tests.rs.
          REQUIRED_WORKFLOWS=("CI" "Documentation Validation")

          FAILED=0
          for WORKFLOW_NAME in "${REQUIRED_WORKFLOWS[@]}"; do
            echo ""
            echo "Checking workflow: $WORKFLOW_NAME"

            WORKFLOW_ID=$(gh api \
              "repos/${{ github.repository }}/actions/workflows" \
              --jq ".workflows[] | select(.name == \"${WORKFLOW_NAME}\") | .id" \
            )

            if [ -z "$WORKFLOW_ID" ]; then
              echo "ERROR: Workflow '${WORKFLOW_NAME}' not found in repository"
              FAILED=1
              continue
            fi

            # Get the most recent completed run for this workflow on the commit's branch
            CONCLUSION=$(gh api \
              "repos/${{ github.repository }}/actions/workflows/${WORKFLOW_ID}/runs?head_sha=${COMMIT_SHA}&status=completed&per_page=1" \
              --jq '.workflow_runs[0].conclusion // empty' \
            )

            if [ -z "$CONCLUSION" ]; then
              echo "ERROR: No completed run found for '${WORKFLOW_NAME}' on commit ${COMMIT_SHA}"
              echo "  Ensure CI has run and completed on this commit before releasing."
              FAILED=1
            elif [ "$CONCLUSION" != "success" ]; then
              echo "ERROR: '${WORKFLOW_NAME}' conclusion is '${CONCLUSION}' (expected 'success')"
              echo "  Fix the failing checks before releasing."
              FAILED=1
            else
              echo "OK: '${WORKFLOW_NAME}' passed on commit ${COMMIT_SHA}"
            fi
          done

          echo ""
          if [ $FAILED -ne 0 ]; then
            echo "=========================================="
            echo "RELEASE BLOCKED: Required CI checks have not passed."
            echo ""
            echo "To fix:"
            echo "  1. Push the release commit to main and wait for CI to complete"
            echo "  2. Verify all required checks are green"
            echo "  3. Then trigger the release workflow again"
            echo "=========================================="
            exit 1
          fi

          echo "All required CI checks passed. Proceeding with release."

  publish:
    needs: [preflight]
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Install Rust
        uses: dtolnay/rust-toolchain@631a55b12751854ce901bb631d5902ceb48146f7 # stable
        with:
          toolchain: stable

      - name: Configure sccache
        id: sccache
        uses: mozilla-actions/sccache-action@7d986dd989559c6ecdb630a3fd2557667be217ad # v0.0.9
        continue-on-error: true

      - name: Verify sccache is working
        id: sccache-check
        if: steps.sccache.outcome == 'success'
        run: |
          if sccache --show-stats > /dev/null 2>&1; then
            echo "working=true" >> "$GITHUB_OUTPUT"
            echo "sccache is operational"
          else
            echo "working=false" >> "$GITHUB_OUTPUT"
            echo "sccache binary not responding"
          fi
        continue-on-error: true

      - name: Clear sccache env on failure
        if: steps.sccache.outcome != 'success' || steps.sccache-check.outcome != 'success'
        run: |
          echo "::warning::sccache unavailable (setup=${{ steps.sccache.outcome }}, check=${{ steps.sccache-check.outcome }}), falling back to standard rustc"
          echo "RUSTC_WRAPPER=" >> "$GITHUB_ENV"
          echo "SCCACHE_GHA_ENABLED=" >> "$GITHUB_ENV"

      - name: Cache cargo registry and build
        uses: actions/cache@d4323d4df104b026a6aa633fdb11d772146be0bf # v4.2.2
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: publish-${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            publish-${{ runner.os }}-cargo-

      - name: Verify version consistency
        run: |
          CARGO_VERSION=$(grep '^version = ' Cargo.toml | head -n1 | cut -d '"' -f2)
          echo "Cargo.toml version: $CARGO_VERSION"

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            INPUT_VERSION="${{ github.event.inputs.release_version }}"
            if [ "$INPUT_VERSION" != "$CARGO_VERSION" ]; then
              echo "Input version $INPUT_VERSION does not match Cargo.toml version $CARGO_VERSION" >&2
              exit 1
            fi
            echo "Input version matches Cargo.toml"
          fi

          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            TAG_VERSION=${GITHUB_REF#refs/tags/}
            if [ "$TAG_VERSION" != "v${CARGO_VERSION}" ]; then
              echo "Tag version $TAG_VERSION does not match Cargo.toml version $CARGO_VERSION" >&2
              exit 1
            fi
            echo "Tag version matches Cargo.toml"
          fi

      - name: Publish (dry-run)
        run: cargo publish --dry-run
        env:
          RUSTC_WRAPPER: ${{ steps.sccache-check.outputs.working == 'true' && 'sccache' || '' }}
          SCCACHE_GHA_ENABLED: ${{ steps.sccache-check.outputs.working == 'true' && 'true' || 'false' }}
          SCCACHE_IGNORE_SERVER_IO_ERROR: "1"
          SCCACHE_STARTUP_NOTIFY_TIMEOUT: "60"
          SCCACHE_IDLE_TIMEOUT: "0"

      - name: Publish to crates.io
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CRATES_IO_TOKEN }}
        run: cargo publish

      - name: Create and push git tag
        if: github.event_name == 'workflow_dispatch'
        run: |
          CARGO_VERSION=$(grep '^version = ' Cargo.toml | head -n1 | cut -d '"' -f2)
          TAG_NAME="v${CARGO_VERSION}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"

      - name: Get version for release
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION=$(grep '^version = ' Cargo.toml | head -n1 | cut -d '"' -f2)
          else
            VERSION=${GITHUB_REF#refs/tags/v}
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=v$VERSION" >> "$GITHUB_OUTPUT"

      - name: Install cargo-sbom
        uses: taiki-e/install-action@f92912fad184299a31e22ad070a5059fd07d4f59 # v2
        with:
          tool: cargo-sbom

      - name: Generate SBOM (CycloneDX)
        run: cargo sbom --output-format cyclone_dx_json_1_5 > sbom.cdx.json
        continue-on-error: true

      - name: Extract changelog for release
        id: changelog
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          # Extract the section for this version from CHANGELOG.md
          # Matches from "## [X.Y.Z]" until the next "## [" or end of file
          CHANGELOG_CONTENT=$(awk -v ver="$VERSION" '
            BEGIN { found=0; printing=0 }
            /^## \[/ {
              if (printing) { exit }
              if ($0 ~ "\\[" ver "\\]") { found=1; printing=1; next }
            }
            printing { print }
          ' CHANGELOG.md)

          if [ -z "$CHANGELOG_CONTENT" ]; then
            CHANGELOG_CONTENT="Release $VERSION"
          fi

          # Write to file to preserve newlines
          echo "$CHANGELOG_CONTENT" > release_notes.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@a06a81a03ee405af7f2048a818ed3f03bbf83c7b # v2.5.0
        with:
          tag_name: ${{ steps.get_version.outputs.tag }}
          name: ${{ steps.get_version.outputs.tag }}
          body_path: release_notes.md
          draft: false
          prerelease: false
          files: sbom.cdx.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
